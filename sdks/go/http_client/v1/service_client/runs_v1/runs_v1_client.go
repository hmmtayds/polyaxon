// Copyright 2018-2020 Polyaxon, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by go-swagger; DO NOT EDIT.

package runs_v1

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"

	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
)

// New creates a new runs v1 API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) ClientService {
	return &Client{transport: transport, formats: formats}
}

/*
Client for runs v1 API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

// ClientService is the interface for Client methods
type ClientService interface {
	ArchiveRun(params *ArchiveRunParams, authInfo runtime.ClientAuthInfoWriter) (*ArchiveRunOK, *ArchiveRunNoContent, error)

	BookmarkRun(params *BookmarkRunParams, authInfo runtime.ClientAuthInfoWriter) (*BookmarkRunOK, *BookmarkRunNoContent, error)

	BookmarkRuns(params *BookmarkRunsParams, authInfo runtime.ClientAuthInfoWriter) (*BookmarkRunsOK, *BookmarkRunsNoContent, error)

	CollectRunLogs(params *CollectRunLogsParams, authInfo runtime.ClientAuthInfoWriter) (*CollectRunLogsOK, *CollectRunLogsNoContent, error)

	CopyRun(params *CopyRunParams, authInfo runtime.ClientAuthInfoWriter) (*CopyRunOK, *CopyRunNoContent, error)

	CreateRun(params *CreateRunParams, authInfo runtime.ClientAuthInfoWriter) (*CreateRunOK, *CreateRunNoContent, error)

	CreateRunArtifactsLineage(params *CreateRunArtifactsLineageParams, authInfo runtime.ClientAuthInfoWriter) (*CreateRunArtifactsLineageOK, *CreateRunArtifactsLineageNoContent, error)

	CreateRunStatus(params *CreateRunStatusParams, authInfo runtime.ClientAuthInfoWriter) (*CreateRunStatusOK, *CreateRunStatusNoContent, error)

	DeleteRun(params *DeleteRunParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteRunOK, *DeleteRunNoContent, error)

	DeleteRunArtifact(params *DeleteRunArtifactParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteRunArtifactOK, *DeleteRunArtifactNoContent, error)

	DeleteRunArtifactLineage(params *DeleteRunArtifactLineageParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteRunArtifactLineageOK, *DeleteRunArtifactLineageNoContent, error)

	DeleteRunArtifacts(params *DeleteRunArtifactsParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteRunArtifactsOK, *DeleteRunArtifactsNoContent, error)

	DeleteRuns(params *DeleteRunsParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteRunsOK, *DeleteRunsNoContent, error)

	GetMultiRunEvents(params *GetMultiRunEventsParams, authInfo runtime.ClientAuthInfoWriter) (*GetMultiRunEventsOK, *GetMultiRunEventsNoContent, error)

	GetRun(params *GetRunParams, authInfo runtime.ClientAuthInfoWriter) (*GetRunOK, *GetRunNoContent, error)

	GetRunArtifact(params *GetRunArtifactParams, authInfo runtime.ClientAuthInfoWriter) (*GetRunArtifactOK, *GetRunArtifactNoContent, error)

	GetRunArtifactLineage(params *GetRunArtifactLineageParams, authInfo runtime.ClientAuthInfoWriter) (*GetRunArtifactLineageOK, *GetRunArtifactLineageNoContent, error)

	GetRunArtifacts(params *GetRunArtifactsParams, authInfo runtime.ClientAuthInfoWriter) (*GetRunArtifactsOK, *GetRunArtifactsNoContent, error)

	GetRunArtifactsLineage(params *GetRunArtifactsLineageParams, authInfo runtime.ClientAuthInfoWriter) (*GetRunArtifactsLineageOK, *GetRunArtifactsLineageNoContent, error)

	GetRunArtifactsLineageNames(params *GetRunArtifactsLineageNamesParams, authInfo runtime.ClientAuthInfoWriter) (*GetRunArtifactsLineageNamesOK, *GetRunArtifactsLineageNamesNoContent, error)

	GetRunArtifactsTree(params *GetRunArtifactsTreeParams, authInfo runtime.ClientAuthInfoWriter) (*GetRunArtifactsTreeOK, *GetRunArtifactsTreeNoContent, error)

	GetRunEvents(params *GetRunEventsParams, authInfo runtime.ClientAuthInfoWriter) (*GetRunEventsOK, *GetRunEventsNoContent, error)

	GetRunLogs(params *GetRunLogsParams, authInfo runtime.ClientAuthInfoWriter) (*GetRunLogsOK, *GetRunLogsNoContent, error)

	GetRunNamespace(params *GetRunNamespaceParams, authInfo runtime.ClientAuthInfoWriter) (*GetRunNamespaceOK, *GetRunNamespaceNoContent, error)

	GetRunResources(params *GetRunResourcesParams, authInfo runtime.ClientAuthInfoWriter) (*GetRunResourcesOK, *GetRunResourcesNoContent, error)

	GetRunSettings(params *GetRunSettingsParams, authInfo runtime.ClientAuthInfoWriter) (*GetRunSettingsOK, *GetRunSettingsNoContent, error)

	GetRunStatuses(params *GetRunStatusesParams, authInfo runtime.ClientAuthInfoWriter) (*GetRunStatusesOK, *GetRunStatusesNoContent, error)

	GetRunsArtifactsLineage(params *GetRunsArtifactsLineageParams, authInfo runtime.ClientAuthInfoWriter) (*GetRunsArtifactsLineageOK, *GetRunsArtifactsLineageNoContent, error)

	ImpersonateToken(params *ImpersonateTokenParams, authInfo runtime.ClientAuthInfoWriter) (*ImpersonateTokenOK, *ImpersonateTokenNoContent, error)

	InvalidateRun(params *InvalidateRunParams, authInfo runtime.ClientAuthInfoWriter) (*InvalidateRunOK, *InvalidateRunNoContent, error)

	InvalidateRuns(params *InvalidateRunsParams, authInfo runtime.ClientAuthInfoWriter) (*InvalidateRunsOK, *InvalidateRunsNoContent, error)

	ListArchivedRuns(params *ListArchivedRunsParams, authInfo runtime.ClientAuthInfoWriter) (*ListArchivedRunsOK, *ListArchivedRunsNoContent, error)

	ListBookmarkedRuns(params *ListBookmarkedRunsParams, authInfo runtime.ClientAuthInfoWriter) (*ListBookmarkedRunsOK, *ListBookmarkedRunsNoContent, error)

	ListRuns(params *ListRunsParams, authInfo runtime.ClientAuthInfoWriter) (*ListRunsOK, *ListRunsNoContent, error)

	NotifyRunStatus(params *NotifyRunStatusParams, authInfo runtime.ClientAuthInfoWriter) (*NotifyRunStatusOK, *NotifyRunStatusNoContent, error)

	PatchRun(params *PatchRunParams, authInfo runtime.ClientAuthInfoWriter) (*PatchRunOK, *PatchRunNoContent, error)

	RestartRun(params *RestartRunParams, authInfo runtime.ClientAuthInfoWriter) (*RestartRunOK, *RestartRunNoContent, error)

	RestoreRun(params *RestoreRunParams, authInfo runtime.ClientAuthInfoWriter) (*RestoreRunOK, *RestoreRunNoContent, error)

	ResumeRun(params *ResumeRunParams, authInfo runtime.ClientAuthInfoWriter) (*ResumeRunOK, *ResumeRunNoContent, error)

	StartRunTensorboard(params *StartRunTensorboardParams, authInfo runtime.ClientAuthInfoWriter) (*StartRunTensorboardOK, *StartRunTensorboardNoContent, error)

	StopRun(params *StopRunParams, authInfo runtime.ClientAuthInfoWriter) (*StopRunOK, *StopRunNoContent, error)

	StopRunTensorboard(params *StopRunTensorboardParams, authInfo runtime.ClientAuthInfoWriter) (*StopRunTensorboardOK, *StopRunTensorboardNoContent, error)

	StopRuns(params *StopRunsParams, authInfo runtime.ClientAuthInfoWriter) (*StopRunsOK, *StopRunsNoContent, error)

	TagRuns(params *TagRunsParams, authInfo runtime.ClientAuthInfoWriter) (*TagRunsOK, *TagRunsNoContent, error)

	UnbookmarkRun(params *UnbookmarkRunParams, authInfo runtime.ClientAuthInfoWriter) (*UnbookmarkRunOK, *UnbookmarkRunNoContent, error)

	UpdateRun(params *UpdateRunParams, authInfo runtime.ClientAuthInfoWriter) (*UpdateRunOK, *UpdateRunNoContent, error)

	UploadRunArtifact(params *UploadRunArtifactParams, authInfo runtime.ClientAuthInfoWriter) (*UploadRunArtifactOK, *UploadRunArtifactNoContent, error)

	UploadRunLogs(params *UploadRunLogsParams, authInfo runtime.ClientAuthInfoWriter) (*UploadRunLogsOK, *UploadRunLogsNoContent, error)

	SetTransport(transport runtime.ClientTransport)
}

/*
  ArchiveRun archives run
*/
func (a *Client) ArchiveRun(params *ArchiveRunParams, authInfo runtime.ClientAuthInfoWriter) (*ArchiveRunOK, *ArchiveRunNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewArchiveRunParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ArchiveRun",
		Method:             "POST",
		PathPattern:        "/api/v1/{owner}/{project}/runs/{uuid}/archive",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ArchiveRunReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *ArchiveRunOK:
		return value, nil, nil
	case *ArchiveRunNoContent:
		return nil, value, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ArchiveRunDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  BookmarkRun bookmarks run
*/
func (a *Client) BookmarkRun(params *BookmarkRunParams, authInfo runtime.ClientAuthInfoWriter) (*BookmarkRunOK, *BookmarkRunNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewBookmarkRunParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "BookmarkRun",
		Method:             "POST",
		PathPattern:        "/api/v1/{owner}/{project}/runs/{uuid}/bookmark",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &BookmarkRunReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *BookmarkRunOK:
		return value, nil, nil
	case *BookmarkRunNoContent:
		return nil, value, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*BookmarkRunDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  BookmarkRuns bookmarks runs
*/
func (a *Client) BookmarkRuns(params *BookmarkRunsParams, authInfo runtime.ClientAuthInfoWriter) (*BookmarkRunsOK, *BookmarkRunsNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewBookmarkRunsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "BookmarkRuns",
		Method:             "POST",
		PathPattern:        "/api/v1/{owner}/{project}/runs/bookmark",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &BookmarkRunsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *BookmarkRunsOK:
		return value, nil, nil
	case *BookmarkRunsNoContent:
		return nil, value, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*BookmarkRunsDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  CollectRunLogs collects run logs
*/
func (a *Client) CollectRunLogs(params *CollectRunLogsParams, authInfo runtime.ClientAuthInfoWriter) (*CollectRunLogsOK, *CollectRunLogsNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCollectRunLogsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "CollectRunLogs",
		Method:             "POST",
		PathPattern:        "/streams/v1/{namespace}/_internal/{owner}/{project}/runs/{uuid}/logs",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CollectRunLogsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *CollectRunLogsOK:
		return value, nil, nil
	case *CollectRunLogsNoContent:
		return nil, value, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CollectRunLogsDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  CopyRun restarts run with copy
*/
func (a *Client) CopyRun(params *CopyRunParams, authInfo runtime.ClientAuthInfoWriter) (*CopyRunOK, *CopyRunNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCopyRunParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "CopyRun",
		Method:             "POST",
		PathPattern:        "/api/v1/{entity.owner}/{entity.project}/runs/{entity.uuid}/copy",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CopyRunReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *CopyRunOK:
		return value, nil, nil
	case *CopyRunNoContent:
		return nil, value, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CopyRunDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  CreateRun creates new run
*/
func (a *Client) CreateRun(params *CreateRunParams, authInfo runtime.ClientAuthInfoWriter) (*CreateRunOK, *CreateRunNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateRunParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "CreateRun",
		Method:             "POST",
		PathPattern:        "/api/v1/{owner}/{project}/runs",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreateRunReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *CreateRunOK:
		return value, nil, nil
	case *CreateRunNoContent:
		return nil, value, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CreateRunDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  CreateRunArtifactsLineage creates bulk run artifacts lineage
*/
func (a *Client) CreateRunArtifactsLineage(params *CreateRunArtifactsLineageParams, authInfo runtime.ClientAuthInfoWriter) (*CreateRunArtifactsLineageOK, *CreateRunArtifactsLineageNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateRunArtifactsLineageParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "CreateRunArtifactsLineage",
		Method:             "POST",
		PathPattern:        "/api/v1/{owner}/{project}/runs/{uuid}/artifacts_lineage",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreateRunArtifactsLineageReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *CreateRunArtifactsLineageOK:
		return value, nil, nil
	case *CreateRunArtifactsLineageNoContent:
		return nil, value, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CreateRunArtifactsLineageDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  CreateRunStatus creates new run status
*/
func (a *Client) CreateRunStatus(params *CreateRunStatusParams, authInfo runtime.ClientAuthInfoWriter) (*CreateRunStatusOK, *CreateRunStatusNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateRunStatusParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "CreateRunStatus",
		Method:             "POST",
		PathPattern:        "/api/v1/{owner}/{project}/runs/{uuid}/statuses",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreateRunStatusReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *CreateRunStatusOK:
		return value, nil, nil
	case *CreateRunStatusNoContent:
		return nil, value, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CreateRunStatusDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  DeleteRun deletes run
*/
func (a *Client) DeleteRun(params *DeleteRunParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteRunOK, *DeleteRunNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteRunParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "DeleteRun",
		Method:             "DELETE",
		PathPattern:        "/api/v1/{owner}/{project}/runs/{uuid}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteRunReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *DeleteRunOK:
		return value, nil, nil
	case *DeleteRunNoContent:
		return nil, value, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*DeleteRunDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  DeleteRunArtifact deletes run artifact
*/
func (a *Client) DeleteRunArtifact(params *DeleteRunArtifactParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteRunArtifactOK, *DeleteRunArtifactNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteRunArtifactParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "DeleteRunArtifact",
		Method:             "DELETE",
		PathPattern:        "/streams/v1/{namespace}/{owner}/{project}/runs/{uuid}/artifact",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteRunArtifactReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *DeleteRunArtifactOK:
		return value, nil, nil
	case *DeleteRunArtifactNoContent:
		return nil, value, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*DeleteRunArtifactDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  DeleteRunArtifactLineage deletes run artifact lineage
*/
func (a *Client) DeleteRunArtifactLineage(params *DeleteRunArtifactLineageParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteRunArtifactLineageOK, *DeleteRunArtifactLineageNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteRunArtifactLineageParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "DeleteRunArtifactLineage",
		Method:             "DELETE",
		PathPattern:        "/api/v1/{owner}/{project}/runs/{uuid}/artifacts_lineage/{name}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteRunArtifactLineageReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *DeleteRunArtifactLineageOK:
		return value, nil, nil
	case *DeleteRunArtifactLineageNoContent:
		return nil, value, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*DeleteRunArtifactLineageDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  DeleteRunArtifacts deletes run artifacts
*/
func (a *Client) DeleteRunArtifacts(params *DeleteRunArtifactsParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteRunArtifactsOK, *DeleteRunArtifactsNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteRunArtifactsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "DeleteRunArtifacts",
		Method:             "DELETE",
		PathPattern:        "/streams/v1/{namespace}/{owner}/{project}/runs/{uuid}/artifacts",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteRunArtifactsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *DeleteRunArtifactsOK:
		return value, nil, nil
	case *DeleteRunArtifactsNoContent:
		return nil, value, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*DeleteRunArtifactsDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  DeleteRuns deletes runs
*/
func (a *Client) DeleteRuns(params *DeleteRunsParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteRunsOK, *DeleteRunsNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteRunsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "DeleteRuns",
		Method:             "DELETE",
		PathPattern:        "/api/v1/{owner}/{project}/runs/delete",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteRunsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *DeleteRunsOK:
		return value, nil, nil
	case *DeleteRunsNoContent:
		return nil, value, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*DeleteRunsDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetMultiRunEvents gets multi runs events
*/
func (a *Client) GetMultiRunEvents(params *GetMultiRunEventsParams, authInfo runtime.ClientAuthInfoWriter) (*GetMultiRunEventsOK, *GetMultiRunEventsNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetMultiRunEventsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetMultiRunEvents",
		Method:             "GET",
		PathPattern:        "/streams/v1/{namespace}/{owner}/{project}/runs/multi/events/{kind}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetMultiRunEventsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *GetMultiRunEventsOK:
		return value, nil, nil
	case *GetMultiRunEventsNoContent:
		return nil, value, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetMultiRunEventsDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetRun gets run
*/
func (a *Client) GetRun(params *GetRunParams, authInfo runtime.ClientAuthInfoWriter) (*GetRunOK, *GetRunNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetRunParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetRun",
		Method:             "GET",
		PathPattern:        "/api/v1/{owner}/{project}/runs/{uuid}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetRunReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *GetRunOK:
		return value, nil, nil
	case *GetRunNoContent:
		return nil, value, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetRunDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetRunArtifact gets run artifact
*/
func (a *Client) GetRunArtifact(params *GetRunArtifactParams, authInfo runtime.ClientAuthInfoWriter) (*GetRunArtifactOK, *GetRunArtifactNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetRunArtifactParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetRunArtifact",
		Method:             "GET",
		PathPattern:        "/streams/v1/{namespace}/{owner}/{project}/runs/{uuid}/artifact",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetRunArtifactReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *GetRunArtifactOK:
		return value, nil, nil
	case *GetRunArtifactNoContent:
		return nil, value, nil
	}
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for runs_v1: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  GetRunArtifactLineage gets run artifacts lineage
*/
func (a *Client) GetRunArtifactLineage(params *GetRunArtifactLineageParams, authInfo runtime.ClientAuthInfoWriter) (*GetRunArtifactLineageOK, *GetRunArtifactLineageNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetRunArtifactLineageParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetRunArtifactLineage",
		Method:             "GET",
		PathPattern:        "/api/v1/{owner}/{project}/runs/{uuid}/artifacts_lineage/{name}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetRunArtifactLineageReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *GetRunArtifactLineageOK:
		return value, nil, nil
	case *GetRunArtifactLineageNoContent:
		return nil, value, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetRunArtifactLineageDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetRunArtifacts gets run artifacts
*/
func (a *Client) GetRunArtifacts(params *GetRunArtifactsParams, authInfo runtime.ClientAuthInfoWriter) (*GetRunArtifactsOK, *GetRunArtifactsNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetRunArtifactsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetRunArtifacts",
		Method:             "GET",
		PathPattern:        "/streams/v1/{namespace}/{owner}/{project}/runs/{uuid}/artifacts",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetRunArtifactsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *GetRunArtifactsOK:
		return value, nil, nil
	case *GetRunArtifactsNoContent:
		return nil, value, nil
	}
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for runs_v1: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  GetRunArtifactsLineage gets run artifacts lineage
*/
func (a *Client) GetRunArtifactsLineage(params *GetRunArtifactsLineageParams, authInfo runtime.ClientAuthInfoWriter) (*GetRunArtifactsLineageOK, *GetRunArtifactsLineageNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetRunArtifactsLineageParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetRunArtifactsLineage",
		Method:             "GET",
		PathPattern:        "/api/v1/{owner}/{project}/runs/{uuid}/artifacts_lineage",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetRunArtifactsLineageReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *GetRunArtifactsLineageOK:
		return value, nil, nil
	case *GetRunArtifactsLineageNoContent:
		return nil, value, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetRunArtifactsLineageDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetRunArtifactsLineageNames gets run artifacts lineage names
*/
func (a *Client) GetRunArtifactsLineageNames(params *GetRunArtifactsLineageNamesParams, authInfo runtime.ClientAuthInfoWriter) (*GetRunArtifactsLineageNamesOK, *GetRunArtifactsLineageNamesNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetRunArtifactsLineageNamesParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetRunArtifactsLineageNames",
		Method:             "GET",
		PathPattern:        "/api/v1/{owner}/{project}/runs/{uuid}/artifacts_lineage/names",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetRunArtifactsLineageNamesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *GetRunArtifactsLineageNamesOK:
		return value, nil, nil
	case *GetRunArtifactsLineageNamesNoContent:
		return nil, value, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetRunArtifactsLineageNamesDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetRunArtifactsTree gets run artifacts tree
*/
func (a *Client) GetRunArtifactsTree(params *GetRunArtifactsTreeParams, authInfo runtime.ClientAuthInfoWriter) (*GetRunArtifactsTreeOK, *GetRunArtifactsTreeNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetRunArtifactsTreeParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetRunArtifactsTree",
		Method:             "GET",
		PathPattern:        "/streams/v1/{namespace}/{owner}/{project}/runs/{uuid}/artifacts/tree",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetRunArtifactsTreeReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *GetRunArtifactsTreeOK:
		return value, nil, nil
	case *GetRunArtifactsTreeNoContent:
		return nil, value, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetRunArtifactsTreeDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetRunEvents gets run events
*/
func (a *Client) GetRunEvents(params *GetRunEventsParams, authInfo runtime.ClientAuthInfoWriter) (*GetRunEventsOK, *GetRunEventsNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetRunEventsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetRunEvents",
		Method:             "GET",
		PathPattern:        "/streams/v1/{namespace}/{owner}/{project}/runs/{uuid}/events/{kind}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetRunEventsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *GetRunEventsOK:
		return value, nil, nil
	case *GetRunEventsNoContent:
		return nil, value, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetRunEventsDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetRunLogs gets run logs
*/
func (a *Client) GetRunLogs(params *GetRunLogsParams, authInfo runtime.ClientAuthInfoWriter) (*GetRunLogsOK, *GetRunLogsNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetRunLogsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetRunLogs",
		Method:             "GET",
		PathPattern:        "/streams/v1/{namespace}/{owner}/{project}/runs/{uuid}/logs",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetRunLogsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *GetRunLogsOK:
		return value, nil, nil
	case *GetRunLogsNoContent:
		return nil, value, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetRunLogsDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetRunNamespace gets run namespace
*/
func (a *Client) GetRunNamespace(params *GetRunNamespaceParams, authInfo runtime.ClientAuthInfoWriter) (*GetRunNamespaceOK, *GetRunNamespaceNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetRunNamespaceParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetRunNamespace",
		Method:             "GET",
		PathPattern:        "/api/v1/{owner}/{project}/runs/{uuid}/namespace",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetRunNamespaceReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *GetRunNamespaceOK:
		return value, nil, nil
	case *GetRunNamespaceNoContent:
		return nil, value, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetRunNamespaceDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetRunResources gets run resources events
*/
func (a *Client) GetRunResources(params *GetRunResourcesParams, authInfo runtime.ClientAuthInfoWriter) (*GetRunResourcesOK, *GetRunResourcesNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetRunResourcesParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetRunResources",
		Method:             "GET",
		PathPattern:        "/streams/v1/{namespace}/{owner}/{project}/runs/{uuid}/resources",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetRunResourcesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *GetRunResourcesOK:
		return value, nil, nil
	case *GetRunResourcesNoContent:
		return nil, value, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetRunResourcesDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetRunSettings gets run settings
*/
func (a *Client) GetRunSettings(params *GetRunSettingsParams, authInfo runtime.ClientAuthInfoWriter) (*GetRunSettingsOK, *GetRunSettingsNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetRunSettingsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetRunSettings",
		Method:             "GET",
		PathPattern:        "/api/v1/{owner}/{project}/runs/{uuid}/settings",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetRunSettingsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *GetRunSettingsOK:
		return value, nil, nil
	case *GetRunSettingsNoContent:
		return nil, value, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetRunSettingsDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetRunStatuses gets run statuses
*/
func (a *Client) GetRunStatuses(params *GetRunStatusesParams, authInfo runtime.ClientAuthInfoWriter) (*GetRunStatusesOK, *GetRunStatusesNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetRunStatusesParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetRunStatuses",
		Method:             "GET",
		PathPattern:        "/api/v1/{owner}/{project}/runs/{uuid}/statuses",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetRunStatusesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *GetRunStatusesOK:
		return value, nil, nil
	case *GetRunStatusesNoContent:
		return nil, value, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetRunStatusesDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetRunsArtifactsLineage gets runs artifacts lineage
*/
func (a *Client) GetRunsArtifactsLineage(params *GetRunsArtifactsLineageParams, authInfo runtime.ClientAuthInfoWriter) (*GetRunsArtifactsLineageOK, *GetRunsArtifactsLineageNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetRunsArtifactsLineageParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetRunsArtifactsLineage",
		Method:             "GET",
		PathPattern:        "/api/v1/{owner}/{project}/runs/artifacts_lineage",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetRunsArtifactsLineageReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *GetRunsArtifactsLineageOK:
		return value, nil, nil
	case *GetRunsArtifactsLineageNoContent:
		return nil, value, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetRunsArtifactsLineageDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  ImpersonateToken impersonates run token
*/
func (a *Client) ImpersonateToken(params *ImpersonateTokenParams, authInfo runtime.ClientAuthInfoWriter) (*ImpersonateTokenOK, *ImpersonateTokenNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewImpersonateTokenParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ImpersonateToken",
		Method:             "POST",
		PathPattern:        "/api/v1/{owner}/{project}/runs/{uuid}/impersonate",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ImpersonateTokenReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *ImpersonateTokenOK:
		return value, nil, nil
	case *ImpersonateTokenNoContent:
		return nil, value, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ImpersonateTokenDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  InvalidateRun invalidates run
*/
func (a *Client) InvalidateRun(params *InvalidateRunParams, authInfo runtime.ClientAuthInfoWriter) (*InvalidateRunOK, *InvalidateRunNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewInvalidateRunParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "InvalidateRun",
		Method:             "POST",
		PathPattern:        "/api/v1/{owner}/{project}/runs/{uuid}/invalidate",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &InvalidateRunReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *InvalidateRunOK:
		return value, nil, nil
	case *InvalidateRunNoContent:
		return nil, value, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*InvalidateRunDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  InvalidateRuns invalidates runs
*/
func (a *Client) InvalidateRuns(params *InvalidateRunsParams, authInfo runtime.ClientAuthInfoWriter) (*InvalidateRunsOK, *InvalidateRunsNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewInvalidateRunsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "InvalidateRuns",
		Method:             "POST",
		PathPattern:        "/api/v1/{owner}/{project}/runs/invalidate",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &InvalidateRunsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *InvalidateRunsOK:
		return value, nil, nil
	case *InvalidateRunsNoContent:
		return nil, value, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*InvalidateRunsDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  ListArchivedRuns lists archived runs for user
*/
func (a *Client) ListArchivedRuns(params *ListArchivedRunsParams, authInfo runtime.ClientAuthInfoWriter) (*ListArchivedRunsOK, *ListArchivedRunsNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListArchivedRunsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ListArchivedRuns",
		Method:             "GET",
		PathPattern:        "/api/v1/archives/{user}/runs",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ListArchivedRunsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *ListArchivedRunsOK:
		return value, nil, nil
	case *ListArchivedRunsNoContent:
		return nil, value, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ListArchivedRunsDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  ListBookmarkedRuns lists bookmarked runs for user
*/
func (a *Client) ListBookmarkedRuns(params *ListBookmarkedRunsParams, authInfo runtime.ClientAuthInfoWriter) (*ListBookmarkedRunsOK, *ListBookmarkedRunsNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListBookmarkedRunsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ListBookmarkedRuns",
		Method:             "GET",
		PathPattern:        "/api/v1/bookmarks/{user}/runs",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ListBookmarkedRunsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *ListBookmarkedRunsOK:
		return value, nil, nil
	case *ListBookmarkedRunsNoContent:
		return nil, value, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ListBookmarkedRunsDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  ListRuns lists runs
*/
func (a *Client) ListRuns(params *ListRunsParams, authInfo runtime.ClientAuthInfoWriter) (*ListRunsOK, *ListRunsNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListRunsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ListRuns",
		Method:             "GET",
		PathPattern:        "/api/v1/{owner}/{project}/runs",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ListRunsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *ListRunsOK:
		return value, nil, nil
	case *ListRunsNoContent:
		return nil, value, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ListRunsDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  NotifyRunStatus notifies run status
*/
func (a *Client) NotifyRunStatus(params *NotifyRunStatusParams, authInfo runtime.ClientAuthInfoWriter) (*NotifyRunStatusOK, *NotifyRunStatusNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewNotifyRunStatusParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "NotifyRunStatus",
		Method:             "POST",
		PathPattern:        "/streams/v1/{namespace}/{owner}/{project}/runs/{uuid}/notify",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &NotifyRunStatusReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *NotifyRunStatusOK:
		return value, nil, nil
	case *NotifyRunStatusNoContent:
		return nil, value, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*NotifyRunStatusDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  PatchRun patches run
*/
func (a *Client) PatchRun(params *PatchRunParams, authInfo runtime.ClientAuthInfoWriter) (*PatchRunOK, *PatchRunNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPatchRunParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "PatchRun",
		Method:             "PATCH",
		PathPattern:        "/api/v1/{owner}/{project}/runs/{run.uuid}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &PatchRunReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *PatchRunOK:
		return value, nil, nil
	case *PatchRunNoContent:
		return nil, value, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*PatchRunDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  RestartRun restarts run
*/
func (a *Client) RestartRun(params *RestartRunParams, authInfo runtime.ClientAuthInfoWriter) (*RestartRunOK, *RestartRunNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRestartRunParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "RestartRun",
		Method:             "POST",
		PathPattern:        "/api/v1/{entity.owner}/{entity.project}/runs/{entity.uuid}/restart",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RestartRunReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *RestartRunOK:
		return value, nil, nil
	case *RestartRunNoContent:
		return nil, value, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*RestartRunDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  RestoreRun restores run
*/
func (a *Client) RestoreRun(params *RestoreRunParams, authInfo runtime.ClientAuthInfoWriter) (*RestoreRunOK, *RestoreRunNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRestoreRunParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "RestoreRun",
		Method:             "POST",
		PathPattern:        "/api/v1/{owner}/{project}/runs/{uuid}/restore",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RestoreRunReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *RestoreRunOK:
		return value, nil, nil
	case *RestoreRunNoContent:
		return nil, value, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*RestoreRunDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  ResumeRun resumes run
*/
func (a *Client) ResumeRun(params *ResumeRunParams, authInfo runtime.ClientAuthInfoWriter) (*ResumeRunOK, *ResumeRunNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewResumeRunParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ResumeRun",
		Method:             "POST",
		PathPattern:        "/api/v1/{entity.owner}/{entity.project}/runs/{entity.uuid}/resume",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ResumeRunReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *ResumeRunOK:
		return value, nil, nil
	case *ResumeRunNoContent:
		return nil, value, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ResumeRunDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  StartRunTensorboard starts run tensorboard
*/
func (a *Client) StartRunTensorboard(params *StartRunTensorboardParams, authInfo runtime.ClientAuthInfoWriter) (*StartRunTensorboardOK, *StartRunTensorboardNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewStartRunTensorboardParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "StartRunTensorboard",
		Method:             "POST",
		PathPattern:        "/api/v1/{owner}/{project}/runs/{uuid}/tensorboard/start",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &StartRunTensorboardReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *StartRunTensorboardOK:
		return value, nil, nil
	case *StartRunTensorboardNoContent:
		return nil, value, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*StartRunTensorboardDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  StopRun stops run
*/
func (a *Client) StopRun(params *StopRunParams, authInfo runtime.ClientAuthInfoWriter) (*StopRunOK, *StopRunNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewStopRunParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "StopRun",
		Method:             "POST",
		PathPattern:        "/api/v1/{owner}/{project}/runs/{uuid}/stop",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &StopRunReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *StopRunOK:
		return value, nil, nil
	case *StopRunNoContent:
		return nil, value, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*StopRunDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  StopRunTensorboard stops run tensorboard
*/
func (a *Client) StopRunTensorboard(params *StopRunTensorboardParams, authInfo runtime.ClientAuthInfoWriter) (*StopRunTensorboardOK, *StopRunTensorboardNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewStopRunTensorboardParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "StopRunTensorboard",
		Method:             "POST",
		PathPattern:        "/api/v1/{owner}/{project}/runs/{uuid}/tensorboard/stop",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &StopRunTensorboardReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *StopRunTensorboardOK:
		return value, nil, nil
	case *StopRunTensorboardNoContent:
		return nil, value, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*StopRunTensorboardDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  StopRuns stops runs
*/
func (a *Client) StopRuns(params *StopRunsParams, authInfo runtime.ClientAuthInfoWriter) (*StopRunsOK, *StopRunsNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewStopRunsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "StopRuns",
		Method:             "POST",
		PathPattern:        "/api/v1/{owner}/{project}/runs/stop",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &StopRunsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *StopRunsOK:
		return value, nil, nil
	case *StopRunsNoContent:
		return nil, value, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*StopRunsDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  TagRuns tags runs
*/
func (a *Client) TagRuns(params *TagRunsParams, authInfo runtime.ClientAuthInfoWriter) (*TagRunsOK, *TagRunsNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewTagRunsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "TagRuns",
		Method:             "POST",
		PathPattern:        "/api/v1/{owner}/{project}/runs/tag",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &TagRunsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *TagRunsOK:
		return value, nil, nil
	case *TagRunsNoContent:
		return nil, value, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*TagRunsDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  UnbookmarkRun unbookmarks run
*/
func (a *Client) UnbookmarkRun(params *UnbookmarkRunParams, authInfo runtime.ClientAuthInfoWriter) (*UnbookmarkRunOK, *UnbookmarkRunNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUnbookmarkRunParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "UnbookmarkRun",
		Method:             "DELETE",
		PathPattern:        "/api/v1/{owner}/{project}/runs/{uuid}/unbookmark",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &UnbookmarkRunReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *UnbookmarkRunOK:
		return value, nil, nil
	case *UnbookmarkRunNoContent:
		return nil, value, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UnbookmarkRunDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  UpdateRun updates run
*/
func (a *Client) UpdateRun(params *UpdateRunParams, authInfo runtime.ClientAuthInfoWriter) (*UpdateRunOK, *UpdateRunNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateRunParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "UpdateRun",
		Method:             "PUT",
		PathPattern:        "/api/v1/{owner}/{project}/runs/{run.uuid}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &UpdateRunReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *UpdateRunOK:
		return value, nil, nil
	case *UpdateRunNoContent:
		return nil, value, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpdateRunDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  UploadRunArtifact uploads an artifact file to a store via run access
*/
func (a *Client) UploadRunArtifact(params *UploadRunArtifactParams, authInfo runtime.ClientAuthInfoWriter) (*UploadRunArtifactOK, *UploadRunArtifactNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUploadRunArtifactParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "UploadRunArtifact",
		Method:             "POST",
		PathPattern:        "/api/v1/{owner}/{project}/runs/{uuid}/artifacts/upload",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"multipart/form-data"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &UploadRunArtifactReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *UploadRunArtifactOK:
		return value, nil, nil
	case *UploadRunArtifactNoContent:
		return nil, value, nil
	}
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for runs_v1: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  UploadRunLogs uploads a logs file to a store via run access
*/
func (a *Client) UploadRunLogs(params *UploadRunLogsParams, authInfo runtime.ClientAuthInfoWriter) (*UploadRunLogsOK, *UploadRunLogsNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUploadRunLogsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "UploadRunLogs",
		Method:             "POST",
		PathPattern:        "/api/v1/{owner}/{project}/runs/{uuid}/logs/upload",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"multipart/form-data"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &UploadRunLogsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *UploadRunLogsOK:
		return value, nil, nil
	case *UploadRunLogsNoContent:
		return nil, value, nil
	}
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for runs_v1: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
